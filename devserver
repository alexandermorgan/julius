#!/usr/bin/env python3

# Script to concurrently run "watchify" and the SimpleHTTPServer module.

from http import server
import pathlib
import subprocess


# list of the JS files that must be compiled with Watchify; it's input filename, then output filename
_COMPILE_WITH_WATCHIFY = [
    ('js/ncoda-init.js', 'js/ncoda.js'),
]

_PATH_TO_WATCHIFY = 'node_modules/watchify/bin/cmd.js'


def the_script():
    # see if we can find/use watchify
    watchify = pathlib.Path(_PATH_TO_WATCHIFY)
    if not watchify.exists():
        print('Could not find Watchify. Is it installed?')
        raise SystemExit(1)
    del watchify  # because this will be a long-running script

    # set up some Watchify instances
    watchify_instances = []
    for each_file in _COMPILE_WITH_WATCHIFY:
        print('Starting Watchify for {}'.format(each_file[0]))
        try:
            kummand = [_PATH_TO_WATCHIFY, each_file[0], '-o', each_file[1]]
            watchify_instances.append(subprocess.Popen(kummand))
        except subprocess.CalledProcessError as cperr:
            print('Encountered the following error while starting Watchify:\n{}'.format(cperr))
            for each_instance in watchify_instances:
                each_instance.terminate()
                each_instance.wait(timeout=30)
            raise SystemExit(1)

    # now run the SimpleHTTPServer
    # we'll catch KeyboardInterrupt so we can try killing babel on the way out
    try:
        print('Starting the HTTPServer')
        server_address = ('', 8000)
        httpd = server.HTTPServer(server_address, server.SimpleHTTPRequestHandler)
        httpd.serve_forever()
    except KeyboardInterrupt:
        print('')
        for each_instance in watchify_instances:
            print('Terminating Watchify with PID {}'.format(each_instance.pid))
            each_instance.terminate()
            each_instance.wait(timeout=30)


if '__main__' == __name__:
    the_script()
else:
    print('This script is only intended to be run from a commandline.')
